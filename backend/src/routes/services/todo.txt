Our fundamental problem: The AI generates a static snapshot, not a performance. Everything fires at t=0.

The key question: Can we get good choreography WITHOUT making AI responsible for timing? (since it'll fuck that up)

My best answer: Hybrid approach with automatic choreography
How it works:
1. AI's job (what it's good at):

Plans WHAT to show and WHY (keep planning phase)
Generates sequence of teaching actions IN ORDER
Focuses on sequential storytelling: "first show curve, then add tangent, then highlight point"
2. Backend's job (validation):

Checks implementation matches plan promises
If plan says "animated tangent sliding" but AI outputs static point → REJECT and retry
This catches the "AI cutting corners" problem


3. Frontend's job (automatic choreography):

Hardcoded animation behavior per object type:
function → always traces (draws left to right over 2s)
slidingTangent → always slides
point with followFunction → always animates
area → always Riemann buildup (rectangles → smooth)
Automatically sequences actions with smart delays:
Previous action finishes → next starts (with slight overlap)
Audio duration known → stretch timing to match
Creates organic flow without AI picking timing

Priority 1 (BIGGEST IMPACT): Function Tracing

Instead of function appearing instantly, it should draw itself left to right over 2-3 seconds.

Implementation:

In FunctionPlot.tsx
Use Three.js Line.geometry.setDrawRange(0, currentPoints)
Animate currentPoints from 0 to total using useFrame hook
Start at 0 points, increment each frame until full curve visible
Code sketch:



const [drawProgress, setDrawProgress] = useState(0);

useFrame((state, delta) => {
  if (drawProgress < 1) {
    setDrawProgress(Math.min(1, drawProgress + delta / 2)); // 2 second trace
  }
});

const visiblePoints = Math.floor(points.length * drawProgress);
lineGeometry.setDrawRange(0, visiblePoints);
This ONE change makes it feel 10x more like 3B1B.



Priority 2: Auto-sequence Actions

In TimelineController.tsx:

Don't execute all actions at once
Add automatic delays between actions:
remove actions: instant (0s)
add function: 2-3s animation
add slidingTangent: 4-6s animation
add point: 0.5s fade
add area: 3-4s animation
add label: 0.3s fade
Logic:

let cumulativeDelay = 0;
actions.forEach((action, i) => {
  setTimeout(() => executeAction(action), cumulativeDelay * 1000);
  cumulativeDelay += getActionDuration(action);
});



Priority 3: Area Riemann Buildup

In ShadeArea.tsx:

Don't show smooth area instantly
Show 8 rectangles → 16 rectangles → 32 rectangles → smooth area
Animate over 3-4 seconds
Stages:

0-1s: 8 rectangles appear
1-2s: morph to 16 rectangles
2-3s: morph to 32 rectangles
3-4s: smooth to filled area
This is what makes integrals feel intuitive and visual.

Priority 4: Smooth Fade In/Out

For points and labels:

Use Three.js material opacity animation
Fade from 0 to 1 over 0.5s (not instant appear)
Fade from 1 to 0 over 0.3s (not instant disappear)




The 4 I gave handle:

✅ Introducing functions (trace)
✅ Showing integrals/accumulation (Riemann buildup)
✅ Not jarring (fade in/out)
✅ Sequential reveal (auto-sequence)
But calculus teaching also needs:

Function morphing - smoothly transform x² into x³ (for showing families of functions, limits, approximations)

Synchronized dual animations - position graph building AS velocity graph builds (for related rates, FTC)

Emphasis/pulse - highlight a specific point or region when narration mentions it ("notice THIS point")

Camera zoom - zoom into x=0 for limit visualization, zoom out to show behavior at infinity

Parametric trace - point traces curve while simultaneously showing x(t) and y(t) (for parametric/polar)

Graph transformation - stretch/compress/shift existing graph (for function transformations)



Reality check: 3B1B doesn't have infinite templates. He probably uses ~10-15 core animation patterns across all videos. The magic is:

Using them at the RIGHT moment
Perfect timing
Combining them smoothly
My honest recommendation:

Build NOW (kills 80% of lifelessness):

Function trace
Auto-sequencing
Riemann buildup
Fade in/out



Build NEXT (after testing for 2-3 days):
5. Function morph (for limits, approximations)
6. Emphasis pulse (for "notice this")
7. Camera zoom (for limit concepts)

Build LATER (when you find specific gaps):
8. Synchronized animations
9. Parametric trace
10. Graph transformations

Start with 4, but yeah - you'll need ~10 total for comprehensive calc coverage. 
Don't try to build all 10 upfront though. Build 4, test with real teaching, see what's missing.